from typing import Sequence

from matplotlib import pyplot as plt
from matplotlib.axes import Axes
from matplotlib.figure import Figure
from pytorch_lightning import Callback, LightningModule, Trainer
from torch import Tensor
import numpy as np


class ImagePlotCallback(Callback):  # pragma: no-cover
	"""
	Takes the logit predictions of a model and when the probabilities of two classes are very close, the model
	doesn't have high certainty that it should pick one vs the other class.

	This callback shows how the input would have to change to swing the model from one label prediction
	to the other.

	In this case, the network predicts a 5... but gives almost equal probability to an 8.
	The images show what about the original 5 would have to change to make it more like a 5 or more like an 8.

	For each confused logit the confused images are generated by taking the gradient from a logit wrt an input
	for the top two closest logits.

	Example::

		from pl_bolts.callbacks.vision import ConfusedLogitCallback
		trainer = Trainer(callbacks=[ConfusedLogitCallback()])


	.. note:: Whenever called, this model will look for ``self.last_batch`` and ``self.last_logits``
			  in the LightningModule.

	.. note:: This callback supports tensorboard only right now.

	Authored by:

		- Alfredo Canziani
	"""

	def __init__(
			self,
	):
		"""
		Args:
			top_k: How many "offending" images we should plot
			projection_factor: How much to multiply the input image to make it look more like this logit label
			min_logit_value: Only consider logit values above this threshold
			logging_batch_interval: How frequently to inspect/potentially plot something
			max_logit_difference: When the top 2 logits are within this threshold we consider them confused
		"""
		super().__init__()
		self.logging_batch_num = 0
		self.data_range = 0

	def on_validation_batch_end(self,
			trainer: Trainer,
			pl_module: LightningModule,
			outputs: Sequence,
			batch: Sequence,
			batch_idx: int,
			dataloader_idx: int,
	) -> None:
		# show images only for first batch
		if batch_idx != self.logging_batch_num:
			return

		# pick the last batch and logits
		x, y = batch
		self.data_range = pl_module.data_range
		try:
			#if pl_module.model_type == 'CXRdecomp2':
			logits = pl_module.last_logits_val
			logits_drr = pl_module.last_logits_drr_val
			self._plot_withdrr(x, y, logits, logits_drr, trainer, 'validation')
			return
			#else:
			#	logits = pl_module.last_logits_val
		except AttributeError as err:
			m = """please track the last_logits in the training_step like so:
		                def training_step(...):
		                    self.last_logits = your_logits
		            """
			raise AttributeError(m) from err
		self._plot(x, y, logits, trainer, 'validation')

	def on_train_batch_end(
			self,
			trainer: Trainer,
			pl_module: LightningModule,
			outputs: Sequence,
			batch: Sequence,
			batch_idx: int,
			dataloader_idx: int,
	) -> None:
		# show images only every x batches
		#if (trainer.batch_idx + 1) % self.logging_batch_interval != 0:  # type: ignore[attr-defined]
		if batch_idx != self.logging_batch_num:
			return

		# pick the last batch and logits
		x, y = batch
		try:
			if pl_module.model_type == 'CXRdecomp2':
				logits = pl_module.last_logits
				logits_drr = pl_module.last_logits_drr
				self._plot_withdrr(x, y, logits, logits_drr, trainer, 'training')
				return
			else:
				logits = pl_module.last_logits
		except AttributeError as err:
			m = """please track the last_logits in the training_step like so:
                def training_step(...):
                    self.last_logits = your_logits
            """
			raise AttributeError(m) from err
		self._plot(x, y, logits, trainer, 'training')

	def _plot_withdrr(
			self,
			x: Tensor,
			y: Tensor,
			logits: Tensor,
			logits_drr: Tensor,
			trainer: Trainer,
			stage: str,
	) -> None:

		for img_i in range(len(x)):
			x_i = x[img_i].cpu().detach().numpy()
			drr_front_i = x_i[0]
			if x_i.shape[0] > 1:
				drr_lat_i = x_i[1]
			if x_i.shape[0] > 2:
				drr_top_i = x_i[2]

			y_i = y[img_i].squeeze(0).cpu().detach().numpy()
			logits_i = logits[img_i].squeeze(0).cpu().detach().numpy()
			logits_drr_i = logits_drr[img_i].cpu().detach().numpy()
			logits_drr_front_i = logits_drr_i[0]
			if logits_drr_i.shape[0] > 1:
				logits_drr_lat_i = logits_drr_i[1]

			slices = [0, 29, 58, 87, 116, 145, 174, 203, 232]
			for i in range(0, 9):
				slice_num = slices[i]
				fig, axarr = plt.subplots(nrows=4, ncols=3, figsize=(15, 13))
				self.__draw_sample(fig, axarr, 0, 0, drr_front_i, f'Front DDR')
				if x_i.shape[0] > 1:
					self.__draw_sample(fig, axarr, 1, 0, drr_lat_i, f'Lateral DDR')
				if x_i.shape[0] > 2:
					self.__draw_sample(fig, axarr, 2, 0, drr_top_i, f'Top DDR')

				self.__draw_sample(fig, axarr, 2, 0, logits_drr_front_i, f'generated front DDR', min_max = True, data_range=self.data_range)
				if logits_drr_i.shape[0] > 1:
					self.__draw_sample(fig, axarr, 3, 0, logits_drr_lat_i, f'generated lat DDR', min_max = True, data_range=self.data_range)
				self.__draw_sample(fig, axarr, 0, 1, y_i[slice_num, :, :], f'true front CT slice-{slice_num}', min_max = True, data_range=self.data_range)
				self.__draw_sample(fig, axarr, 1, 1, np.transpose(y_i[:, :, slice_num], (1, 0)), f'true lat CT slice-{slice_num}', min_max = True, data_range=self.data_range)
				self.__draw_sample(fig, axarr, 2, 1, y_i[:, slice_num, :], f'true top CT slice-{slice_num}', min_max = True, data_range=self.data_range)
				self.__draw_sample(fig, axarr, 0, 2, logits_i[slice_num, :, :], f'generated front slice-{slice_num}', min_max = True, data_range=self.data_range)
				self.__draw_sample(fig, axarr, 1, 2, np.transpose(logits_i[:, :, slice_num], (1, 0)), f'generated lat slice-{slice_num}', min_max = True, data_range=self.data_range)
				self.__draw_sample(fig, axarr, 2, 2, logits_i[:, slice_num, :], f'generated top slice-{slice_num}', min_max = True, data_range=self.data_range)

				trainer.logger.experiment.add_figure(f'{stage}_imgs/slice{slice_num}', fig, global_step=trainer.global_step)
				plt.close()


	def _plot(
			self,
			x: Tensor,
			y: Tensor,
			logits: Tensor,
			trainer: Trainer,
			stage: str,
	) -> None:

		for img_i in range(len(x)):
			x_i = x[img_i].cpu().detach().numpy()
			drr_front_i = x_i[0]
			if x_i.shape[0] > 1:
				drr_lat_i = x_i[1]
			if x_i.shape[0] > 2:
				drr_top_i = x_i[2]

			y_i = y[img_i].squeeze(0).cpu().detach().numpy()
			logits_i = logits[img_i].squeeze(0).cpu().detach().numpy()

			slices = [0, 29, 58, 87, 116, 145, 174, 203, 232]
			for i in range(0, 9):
				slice_num = slices[i]
				fig, axarr = plt.subplots(nrows=3, ncols=3, figsize=(15, 10))
				self.__draw_sample(fig, axarr, 0, 0, drr_front_i, f'Front DDR')
				if x_i.shape[0] > 1:
					self.__draw_sample(fig, axarr, 1, 0, drr_lat_i, f'Lateral DDR')
				if x_i.shape[0] > 2:
					self.__draw_sample(fig, axarr, 2, 0, drr_top_i, f'Top DDR')
				#self.__draw_sample(fig, axarr, 2, 0, drr_top_i, f'Top DDR')
				self.__draw_sample(fig, axarr, 0, 1, y_i[slice_num, :, :], f'true front CT slice-{slice_num}', min_max = True,data_range=self.data_range)
				self.__draw_sample(fig, axarr, 1, 1, np.transpose(y_i[:, :, slice_num], (1, 0)), f'true lat CT slice-{slice_num}', min_max = True,data_range=self.data_range)
				self.__draw_sample(fig, axarr, 2, 1, y_i[:, slice_num, :], f'true top CT slice-{slice_num}', min_max = True,data_range=self.data_range)
				self.__draw_sample(fig, axarr, 0, 2, logits_i[slice_num, :, :], f'generated front slice-{slice_num}', min_max = True,data_range=self.data_range)
				self.__draw_sample(fig, axarr, 1, 2, np.transpose(logits_i[:, :, slice_num], (1, 0)), f'generated lat slice-{slice_num}', min_max = True,data_range=self.data_range)
				self.__draw_sample(fig, axarr, 2, 2, logits_i[:, slice_num, :], f'generated top slice-{slice_num}', min_max = True, data_range=self.data_range)

				trainer.logger.experiment.add_figure(f'{stage}_imgs/slice{slice_num}', fig, global_step=trainer.global_step)
				plt.close()


	@staticmethod
	def __draw_sample(fig: Figure, axarr: Axes, row_idx: int, col_idx: int, img: Tensor, title: str, min_max=False, data_range=1.) -> None:
		if not min_max:
			im = axarr[row_idx, col_idx].imshow(img, cmap='gray')
		else:
			im = axarr[row_idx, col_idx].imshow(img, cmap='gray', vmin=0, vmax=data_range)
		fig.colorbar(im, ax=axarr[row_idx, col_idx])
		axarr[row_idx, col_idx].set_title(title, fontsize=20)
